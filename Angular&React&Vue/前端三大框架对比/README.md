# 前端三大框架#

## Vue##

Vue是尤雨溪编写的一个构建数据驱动的Web界面的库，准确来说不是一个框架，它聚焦在V（view）视图层。

可能有些方面是不如React，不如Angular，但它是渐进的，没有强主张，你可以在原有大系统的上面，把一两个组件改用它实现；也可以整个用它全家桶开发；还可以用它的视图，搭配你自己设计的整个下层用。你可以在底层数据逻辑的地方用OO和设计模式的那套理念，也可以函数式，都可以，它只是个轻量视图而已，只做了自己该做的事，没有做不该做的事，仅此而已。

渐进式的含义：没有多做职责之外的事。

**特点：**

- 使用 Virtual DOM，有较高的运行速度
- 提供组件化功能
- 可使用mobx与vuex进行状态管理，响应式、依赖追踪
- 可使用JSX，但推荐使用模版语言而不是JSX
- 学习曲线平缓
- 双向数据绑定
- 指令
- 插件化

**优点：**

- 简单：更轻量，单页面，官方文档很清晰，比 Angular 简单易学。
- 快速：异步批处理方式更新 DOM。
- 组合：用解耦的、可复用的组件组合你的应用程序。
- 紧凑：~18kb min+gzip，且无依赖。
- 强大：表达式 无需声明依赖的可推导属性 (computed properties)。
- 对模块友好：可以通过 NPM、Bower 或 Duo 安装，不强迫你所有的代码都遵循 Angular 的各种规定，使用场景更加灵活。

**缺点**

- 新生儿：Vue.js是一个新的项目，没有angular那么成熟。
- 影响度不是很大：有关于Vue.js多样性或者说丰富性少于其他一些有名的库。
- 不支持IE8

## React##

React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站， 并于 2013年 5 月开源。React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。

它有一定程度的主张，它的主张主要是函数式编程的理念，比如说，你需要知道什么是副作用，什么是纯函数，如何隔离副作用。它的侵入性看似没有Angular那么强，主要因为它是软性侵入。

你可以只用React的视图层，但几乎没有人这么用，为什么呢，因为你用了它，就会觉得其他东西都很别扭，于是你要引入Flux，Redux，Mobx之中的一个，于是你除了Redux，还要看saga，于是你要纠结业务开发过程中每个东西有没有副作用，纯不纯，甚至你连这个都可能不能忍：

const getData = () => {

// 如果不存在，就在缓存中创建一个并返回

// 如果存在，就从缓存中拿

}

因为你要纠结它有外部依赖，同样是不加参数调用，连续两次的结果是不一样的，于是不纯。

**特点**：

- 使用 Virtual DOM，有较高的运行速度
- 提供组件化功能
- 可使用mobx与vuex **（对，react用vuex，就是可以这样骚操作😂）** 进行状态管理，响应式、依赖追踪
- 子组件重复渲染问题需要手动优化
- 可以使用redux进行状态管理，函数式、不可变、模式化，时间旅行
- 可使用JSX，完全的javascript能力
- 更繁荣的社区生态

- 声明式设计：React采用声明范式，可以轻松描述应用。
- 高效：React通过对DOM的模拟，最大限度地减少与DOM的交互。
- 灵活：React可以与已知的库或框架很好地配合。

**优点：**

- 速度快：在UI渲染过程中，React通过在虚拟DOM中的微操作来实现对实际DOM的局部更新。
- 跨浏览器兼容：虚拟DOM帮助我们解决了跨浏览器问题，它为我们提供了标准化的API，甚至在IE8中都是没问题的。
- 模块化：为你程序编写独立的模块化UI组件，这样当某个或某些组件出现问题是，可以方便地进行隔离。
- 单向数据流：Flux是一个用于在JavaScript应用中创建单向数据层的架构，它随着React视图库的开发而被Facebook概念化。
- 同构、纯粹的javascript：因为搜索引擎的爬虫程序依赖的是服务端响应而不是JavaScript的执行，预渲染你的应用有助于搜索引擎优化。
- 兼容性好：比如使用RequireJS来加载和打包，而Browserify和Webpack适用于构建大型应用。它们使得那些艰难的任务不再让人望而生畏。*

**缺点：**

- React本身只是一个V而已，并不是一个完整的框架，所以如果是大型项目想要一套完整的框架的话，基本都需要加上ReactRouter和Flux才能写大型应用。

## Angular##

Angular是一款优秀的前端JS框架，已经被用于Google的多款产品当中。

它两个版本都是强主张的，如果你用它，必须接受以下东西：

- 必须使用它的模块机制
- 必须使用它的依赖注入
- 必须使用它的特殊形式定义组件（这一点每个视图框架都有，难以避免）

所以Angular是带有比较强的排它性的，如果你的应用不是从头开始，而是要不断考虑是否跟其他东西集成，这些主张会带来一些困扰。

**特点：**

- 完善的MV*框架，包含模板，数据双向绑定，路由，模块化，服务，过滤器，依赖注入等所有功能
- Typescript
- 脏检查，对脏数据的检查就是脏检查，比较UI和后台的数据是否一致
- 良好的应用程序结构
- 双向数据绑定
- 指令
- HTML模板
- 可嵌入、注入和测试

**优点：**

- 模块化功能强大、自定义directive非常灵活、双向数据绑定，依赖注入
- 模板功能强大丰富，自带了极其丰富的angular指令。
- 是一个比较完善的前端框架，包含服务，模板，数据双向绑定，模块化，路由，过滤器，依赖注入等所有功能；
- 自定义指令，自定义指令后可以在项目中多次使用。
- ng模块化比较大胆的引入了Java的一些东西（依赖注入），能够很容易的写出可复用的代码，对于敏捷开发的团队来说非常有帮助。
- angularjs是互联网巨人谷歌开发，这也意味着他有一个坚实的基础和社区支持。

**缺点：**

- 比较笨重，大而全大框架，学习成本高，不兼容IE6/7
- angular 入门很容易 但深入后概念很多, 学习中较难理解.
- 文档例子非常少, 官方的文档基本只写了api, 一个例子都没有, 很多时候具体怎么用都是google来的, 或直接问misko,angular的作者.
- 对IE6/7 兼容不算特别好, 就是可以用jQuery自己手写代码解决一些.
- 指令的应用的最佳实践教程少, angular其实很灵活, 如果不看一些作者的使用原则,很容易写出 四不像的代码, 例如js中还是像jQuery的思想有很多dom操作.
- DI 依赖注入 如果代码压缩需要显示声明.

## 对比##

现在前端三大框架Angular、React、Vue各有所长。Angular从一开始就带有很明显的工程化血统，齐全的cli命令，背靠TypeScript，涉及模块、服务以及指令等概念，使用后端的依赖注入思想，特有模板语法。React和Vue就"轻"很多，React甚至只是一个UI库，他们共同的一个思想就是，做到最好。

MVVM 列表渲染的初始化几乎一定比 Virtual DOM 慢，因为创建 ViewModel / scope 实例比起 Virtual DOM 来说要昂贵很多

- ## 数据

Angular 使用双向绑定即：界面的操作能实时反映到数据，数据的变更能实时展现到界面。

1. 它的实现原理：

   scope.$watch时只为它传递了一个参数，无论作用域中的什么东西发生了变化，这个函数都会被调用。在ng-model中，这个函数被用来检查模型和视图有没有同步，如果没有同步，它将会使用新值来更新模型数据。   

2. 双向绑定的三个重要方法：

   apply()；digest()；watch()。在angularjs双向绑定中，有2个很重要的概念叫做dirty check，digest loop。dirty check（脏检测）是用来检查绑定的scope中的对象的状态的，例如，在js里创建了一个对象，并且把这个对象绑定在scope下，这样这个对象就处于digest loop中，loop通过遍历这些对象来发现他们是否改变，如果改变就会调用相应的处理方法来实现双向绑定。

   Vue 也支持双向绑定，默认为单向绑定，数据从父组件单向传给子组件。在大型应用中使用单向绑定让数据流易于理解。   

3. 脏检测的利弊：

   和ember.js等技术的getter/setter观测机制相比（优）：  getter/setter当每次对DOM产生变更，它都要修改DOM树的结构，性能影响大，Angular会把批量操作延时到一次更新，性能相对较好。  和Vue相比（劣）：  Vue.js 有更好的性能，并且非常非常容易优化，因为它不使用脏检查。Angular，当 watcher 越来越多时会变得越来越慢，因为作用域内的每一次变化，所有 watcher 都要重新计算。并且，如果一些 watcher 触发另一个更新，脏检查循环（digest cycle）可能要运行多次。 Angular 用户常常要使用深奥的技术，以解决脏检查循环的问题。有时没有简单的办法来优化有大量 watcher 的作用域。Vue.js 则根本没有这个问题，因为它使用基于依赖追踪的观察系统并且异步列队更新，所有的数据变化都是独立地触发，除非它们之间有明确的依赖关系。唯一需要做的优化是在 v-for 上使用 track-by。  React-单向数据流  MVVM流的Angular和Vue，都是通过类似模板的语法，描述界面状态与数据的绑定关系，然后通过内部转换，把这个结构建立起来，当界面发生变化的时候，按照配置规则去更新相应的数据，然后，再根据配置好的规则去，从数据更新界面状态。  React推崇的是函数式编程和单向数据流：给定原始界面（或数据），施加一个变化，就能推导出另外一个状态（界面或者数据的更新）。  React和Vue都可以配合Redux来管理状态数据。   

- ## 视图渲染

1. AngularJS的工作原理是:

   HTML模板将会被浏览器解析到DOM中, DOM结构成为AngularJS编译器的输入。AngularJS将会遍历DOM模板, 来生成相应的NG指令,所有的指令都负责针对view(即HTML中的ng-model)来设置数据绑定。因此, NG框架是在DOM加载完成之后, 才开始起作用的。

   React：

   React 的渲染建立在 Virtual DOM 上 ——一种在内存中描述 DOM 树状态的数据结构。 当状态发生变化时，React 重新渲染 Virtual DOM，比较计算之后给真实 DOM 打补丁 。 Virtual DOM ：  提供了函数式的方法描述视图， 它不使用数据观察机制，每次更新都会重新渲染整个应用，因此从定义上保证了视图与数据的同步 。它也开辟了 Java 同构应用的可能性。  在 超大量数据的首屏渲染速度 上， React 有一定优势 ，因为 Vue 的渲染机制启动时候要做的工作比较多 ，而且 React 支持服务端渲染 。React 的 Virtual DOM 也需要优化 。

   复杂的应用里可以选择

   1. 手动添加 shouldComponentUpdate 来避免不需要的 vdom re-render；

   2. Components 尽可能都用 pureRenderMixin，然后采用 Flux 结构 + Immutable.js。

      其实也不是那么简单的。相比之下， Vue 由于采用 依赖追踪 ，默认就是优化状态： 动了多少数据，就触发多少更新，不多也不少 。React 和 Angular 2 都有服务端渲染和原生渲染的功能。 Vue.js 不使用 Virtual DOM 而是 使用真实 DOM 作为模板，数据绑定到真实节点 。Vue.js 的应用环境必须提供 DOM。 Vue.js 有时性能会比 React 好 ，而且几乎不用手工优化。   

- ## 性能与优化    

  性能方面，这几个主流框架都应该可以轻松应付大部分常见场景的性能需求，区别在于可优化性和优化对于开发体验的影响。Vue 的话需要加好 track-by 。React 需要 shouldComponentUpdate 或者全面 Immutable，Angular 2 需要手动指定 change detection strategy。从整体趋势上来说，浏览器和手机还会越变越快，框架本身的渲染性能在整个前端性能优化体系中，会渐渐淡化，更多的优化点还是在构建方式、缓存、图片加载、网络链路、HTTP/2 等方面   

- ## 模块化与组件 

  Angular1 -&gt; Angular2：

  Angular1使用依赖注入来解决模块之间的依赖问题，模块几乎都依赖于注入容器以及其他相关功能。不是异步加载的，根据依赖列出第一次加载所需的所有依赖。  可以配合类似于Require.js来实现异步加载，懒加载（按需加载）则是借助于 ocLazyLoad 方式的解决方案，但是理想情况下应该是本地框架会更易懂。  Angular2使用ES6的module来定义模块，也考虑了动态加载的需求。

  Vue：

  Vue中指令和组件分得更清晰。 指令只封装 DOM 操作，而组件代表一个自给自足的独立单元 —— 有自己的视图和数据逻辑 。在 Angular1 中两者有不少相混的地方。

  React：

  一个 React 应用就是构建在 React 组件之上的 。  组件有两个核心概念：props,state。 一个组件就是通过这两个属性的值在 render 方法里面生成这个组件对应的 HTML 结构。  传统的 MVC 是将模板放在其他地方，比如 标签或者模板文件，再在 JS 中通过某种手段引用模板。按这种思路，想想多少次我们面对四处分散的模板片段不知所措？纠结模板引擎，纠结模板存放位置，纠结如何引用模板。  React 认为组件才是王道，而组件是和模板紧密关联的，组件模板和组件逻辑分离让问题复杂化了。所以就有了 JSX 这种语法，就是为了把 HTML 模板直接嵌入到 JS 代码里面，这样就做到了模板和组件关联，但是 JS 不支持这种包含 HTML 的语法，所以需要通过工具将 JSX 编译输出成 JS 代码才能使用（可以进行跨平台开发的依据，通过不同的解释器解释成不同平台上运行的代码，由此可以有RN和React开发桌面客户端）。   

## 我们如何选？  

年轻的程序员都是好奇的猫，玩过一个又一个的前端框架。从毛球上弄出一条条的线，玩啊玩，最后这一个个的框架在脑子里搅浆糊。有太多的选择，就是一件麻烦的事；没有选择时，就是一件更麻烦的事；有唯一的选择时，事情就会变得超级简单。  当一个程序员学了某个最新的框架之后，通常来说这个框架有着更多的优点，这个时候最容易出现的想法就是替换现有的框架，科室现有的框架并没有什么大的问题，并且评估不充分的时候，新的框架则会有更多的风险。  所以最后总结一下：技术选型没有银弹，没有一个框架能够解决所有的问题。这时，为了更好的考量不同的因素，你需要列出重要的象限，如开发效率，团队喜好，开发周期等时机情况选择哪个框架最合适你当前的团队和项目。 

**在大型超大型web应用上，看好Angular**

深 度整合Typescript和Rxjs。ts解决了工程化的问题，rxjs解决了开发速度的问题。但是学习成本，可能对于Java，c#等OOP工程师来说比较容易上手，但是对于JavaScript工程师来说，少有工程化的经验，接受起来比较痛苦。当然，不只是Angular可以采用Typescript开发，很多其他的Dom库都可以，Angular相比他们的优势在于：

- 零配置
- 深度整合设计模式
- 约定才是框架的本质

尤其是第三条，相信很多天才程序员都能复现Angular的设计模式和功能，但是由于并非“框架”，没有其他程序员跟进，显然就不能适用于大型超大型应用，毕竟对于大项目来说，沟通往往会成为开发瓶颈。

 rxjs很多人认为太重，没有必要，当然你也可以用很不优雅的toPromise方法来处理异步操作，甚至直接用behaviorObject.value也可以，但是当异步操作繁杂，重复，非一致的时候，rxjs可以很优雅地保证数据的稳定。rxjs的运用一方面是为了处理这种复杂的异步逻辑，另一方面，就是为了让异步数据流可以声明，而不用像promise那样声明冗长，或者async await那样函数化，响应式是基于数据的响应式而不是基于函数。

**在小型应用上，看好vue**

其实绝大部分web应用，都应该只是小型应用。公司官网，论坛，甚至是规模不大的电子商务网站和基本功能的OA，ERP系统，都只是小型web应用。它们数据源稳定，对于运营的要求不高，但是对加载速度等都有很高的要求。这个时候，小巧的vue就成了首选。Proxy实现的响应式相比Angular的zone暴力代理和rxjs的复杂操作显得更加接地气，不需要额外地进行学习。对象式的声明在UI实现上速度更快。生态虽然没有react那么热闹但是小而美的库也很多，nuxt的实现值得点赞。

**个性化需求、中型应用，更倾向react**

在中大型应用中，不是一定要搞Java那一套的，而且在前端这种对工期要求很紧的领域，没必要因为添加新功能而更换新的平台，能用到rxjs和依赖注入的前端应用场景并不多。所以如果采用react，从项目一开始就渐进式地添加模块，往往更适合快速发展的产品。

